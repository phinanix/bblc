
11 July 24

reduction -> 18 | 1 | dup dup
loops ->     22 | 3 | dup trip

subsets ->   24 | 1 | dup (位x. x (id x))
DRO ->       >=27

Checking only for halting and loops, unsolved terms by size
22  3     3
23  0     3
24  5     8
25  7     15
26  22    37
27  12    49
28  128   177
29  140   317
30  337   654
31  527   1181
32 

the above numbers were wrong, oops 
new numbers, loops only: 
22  3     3
23  0     3
24  5     8
25  6     14
26  22    36
27  11    47
28  101   148
29  136   284
30  303   587
31  442   1029
32  1228  2257

31 = 309 + 133 = 442
32 = 765 + 463 = 1228

loops and (weak) 
subsets:
22  0     0
23  0     0
24  3     3
25  5     8
26  8     16
27  7     23
28  41    64
29  70    134
30  170   304
31  309   613
32  765   1378

loops and strong subsets, unverifited
22  0     0
23  0     0
24  1     1
25  3     4
26  1     5
27  4     9
28  11    20
29  25    45
30  47    92
31  130   228
32  221   449

term that crashes min_loop: (位(1)1) 位((1)位2) 位(1)2
term that OOMs: 
size 30 reducing A 位A11  位位A A22 A11
size 30 reducing A位A11位位AA22A11
another term that crashes min_loop (this time of size 31): A 位A11 位A  A1 位A1位2  1


twi stuff
528 -> 580 twi code (53 lines)
581 -> 750 mostly duplicated  (169 lines)
total: 222 lines

twi notes: 
I went to a lot of trouble and duplicating code to make the twi thing, but I think
in retrospect the move was probably actually just to use the built in hash function?
the term to u64 thing I wrote is basically a hash, and the caching is done in a very
inefficient way, so it is probably better to not cache at all, would be my guess. 

separately, I was expecting subsets to solve up to size 25, but I'm no longer sure 
that is correct. there are 4 terms remaining at size 24, of which it looks at a 
glance like 2 of them are things we "should solve" and 2 are things that aren't 
solved by subsets (but are solved by different-reduction-order). The latter 2 
are just versions of the size 25 terms needing DRO that I already knew about, 
but I missed previously. 

terms that will not be solved by better subsets 
then terms that will not be solved by DRO 
24  1  0
25  3  0
26  2  (0 or 1)
27  

位A位A11位AA11位1 might not be solved by DRO (?) (size 26)

位A 位A11 位AA11位1

位A 位A11 位A1A位11

july 11 todos
* prove a better theorem about subsets
* implement the better subset decider
* mb display looping or subsetting more accurately
* implement different-reduction-order 
* implement subset using just hashes and check if it is faster


size 26 | subset | DRO 
位位A位A11位A1A11 | y | y
位位A位A11位AA111 | y | y
位A位A11位A1A位11 | n | y
位A位A11位AA11位1 | y | y (I think? / mb more complex / mb not) 
(actually it is solveable with subset, even though I first thought it wasn't)
A位位A22位A1A11  | y | y
A位位A22位AA111  | y | y
A位A1A11位AA111 | y | y
A位AA111位A1A11 | y | y

size 27 | subset | DRO
位位A位A11位A2A11 | y? | 
位位A位A11位AA112 | y? | 
位A位A11位A1位A21 | ? | ?
位A位A11位A1A1位2 | n? | ?
位A位A11位A1A位21 | y | y
位A位A11位AA11位2 | ? | ?
A位A11位A1A位2位1 | n | y 


size: 30
num terms: 293840
terms red
terms loop
thread 'main' panicked at src/main.rs:907:25:
subsets limit should be smaller than red limit 位AA位A11位A1A位111 位A11
subsets limit should be smaller than red limit 位((位(1)1)位(1)(位1)1)1 位(1)1

0 位((位(1)1)位(1)(位1)1)1
1 位((位(1)(位1)1)位(1)(位1)1)1
2 位((位(1)(位1)1)(位1)位(1)(位1)1)1
3 位(((位1)位(1)(位1)1)(位1)(位1)位(1)(位1)1)1
4 位(位(1)(位1)1)1
5 位(1)(位1)1
6 位(1)1

step 0 size 30 term 位((位(1)1)位(1)(位1)1)1
step 1 size 36 term 位((位(1)(位1)1)位(1)(位1)1)1
step 2 size 42 term 位((位(1)(位1)1)(位1)位(1)(位1)1)1
step 3 size 54 term 位(((位1)位(1)(位1)1)(位1)(位1)位(1)(位1)1)1
step 4 size 48 term 位((位(1)(位1)1)(位1)(位1)位(1)(位1)1)1
step 5 size 66 term 位(((位1)(位1)位(1)(位1)1)(位1)(位1)(位1)位(1)(位1)1)1
step 6 size 60 term 位(((位1)位(1)(位1)1)(位1)(位1)(位1)位(1)(位1)1)1
step 7 size 54 term 位((位(1)(位1)1)(位1)(位1)(位1)位(1)(位1)1)1
step 8 size 78 term 位(((位1)(位1)(位1)位(1)(位1)1)(位1)(位1)(位1)(位1)位(1)(位1)1)1
step 9 size 72 term 位(((位1)(位1)位(1)(位1)1)(位1)(位1)(位1)(位1)位(1)(位1)1)1

it's the 3->4 reduction that breaks!
